/**
 * SAML Callback Integration Tests
 * Tests the SAML callback endpoint with full validation chain
 *
 * This is the CRITICAL security boundary where SAML responses are validated
 *
 * Pattern: Follows tests/integration/auth-flow.test.ts
 */

import { describe, it, expect, beforeEach } from 'vitest'
import '@/tests/setup/integration-setup' // Transaction-based isolation
import { createTestUser } from '@/tests/factories/user-factory'
import {
  postSAMLCallback,
  verifySAMLAssertionTracked,
  verifySAMLAuthenticationCookies,
  SAMLResponseFactory,
  SAMLTestScenarios,
  cleanupSAMLAssertions
} from '@/tests/helpers/saml-helper'
import type { User } from '@/lib/db/schema'

describe('SAML Callback Integration', () => {
  let testUser: User
  let ssoOnlyUser: User

  beforeEach(async () => {
    // Create regular user (has password)
    testUser = await createTestUser({
      email: 'saml.user@bendcare.com',
      password: 'TestPassword123!'
    })

    // Create SSO-only user (no password)
    ssoOnlyUser = await createTestUser({
      email: 'sso.only@bendcare.com',
      password_hash: null // SSO-only - no password
    })
  })

  describe('Valid SAML Response', () => {
    it('should authenticate user with valid SAML response', async () => {
      // Test business outcome: Valid SAML response creates authenticated session
      const samlResponse = SAMLResponseFactory.valid(testUser.email)

      const response = await postSAMLCallback(samlResponse)

      // Should return success (200 with HTML or 302 redirect)
      expect([200, 302]).toContain(response.status)

      // Should set authentication cookies
      const cookies = verifySAMLAuthenticationCookies(response)
      expect(cookies.hasAccessToken).toBe(true)
      expect(cookies.hasRefreshToken).toBe(true)
      expect(cookies.accessToken).toBeTruthy()
      expect(cookies.refreshToken).toBeTruthy()
    })

    it('should track assertion ID to prevent replay attacks', async () => {
      const assertionId = '_test_assertion_unique_123'
      const samlResponse = SAMLResponseFactory.withAssertionId(
        testUser.email,
        assertionId
      )

      await postSAMLCallback(samlResponse)

      // Verify assertion ID is tracked in database
      const isTracked = await verifySAMLAssertionTracked(assertionId)
      expect(isTracked).toBe(true)
    })

    it('should authenticate SSO-only user (no password)', async () => {
      // Test business logic: SSO-only users can authenticate via SAML
      const samlResponse = SAMLResponseFactory.valid(ssoOnlyUser.email)

      const response = await postSAMLCallback(samlResponse)

      expect([200, 302]).toContain(response.status)

      const cookies = verifySAMLAuthenticationCookies(response)
      expect(cookies.hasAccessToken).toBe(true)
    })

    it('should extract and sanitize user attributes from SAML', async () => {
      const samlResponse = SAMLResponseFactory.withAttributes(testUser.email, {
        displayName: 'Test User',
        givenName: 'Test',
        surname: 'User'
      })

      const response = await postSAMLCallback(samlResponse)

      expect([200, 302]).toContain(response.status)
      // Note: Actual attribute storage would be verified via database query
      // For now, we verify the request doesn't fail
    })
  })

  describe('Security Validations - Replay Attack Prevention', () => {
    it('should reject duplicate SAML response (replay attack)', async () => {
      const assertionId = '_replay_prevention_test_456'
      const samlResponse = SAMLResponseFactory.withAssertionId(
        testUser.email,
        assertionId
      )

      // First request should succeed
      const firstResponse = await postSAMLCallback(samlResponse)
      expect([200, 302]).toContain(firstResponse.status)

      // Second request with same assertion ID should fail
      const secondResponse = await postSAMLCallback(samlResponse)

      // Should redirect to login with error
      expect(secondResponse.status).toBe(302)
      const location = secondResponse.headers.get('location')
      expect(location).toContain('/signin')
      expect(location).toContain('error=')
    })

    it('should track security context for replay attempts', async () => {
      const assertionId = '_replay_security_context_789'
      const samlResponse = SAMLResponseFactory.withAssertionId(
        testUser.email,
        assertionId
      )

      await postSAMLCallback(samlResponse, {
        headers: {
          'X-Forwarded-For': '192.168.1.100',
          'User-Agent': 'Test Browser'
        }
      })

      // Verify security context was captured
      const isTracked = await verifySAMLAssertionTracked(assertionId)
      expect(isTracked).toBe(true)
    })
  })

  describe('Security Validations - Timestamp Validation', () => {
    it('should reject expired SAML response', async () => {
      // Test business logic: Expired SAML assertions are rejected
      const expiredResponse = SAMLResponseFactory.expired(testUser.email)

      const response = await postSAMLCallback(expiredResponse)

      // Should fail authentication
      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
      expect(location).toContain('error=')
    })
  })

  describe('Security Validations - Tenant Isolation', () => {
    it('should reject SAML response from wrong tenant', async () => {
      // Test critical security: Prevent tenant bypass attacks
      const wrongTenantResponse = SAMLResponseFactory.wrongTenant(testUser.email)

      const response = await postSAMLCallback(wrongTenantResponse)

      // Should reject due to issuer validation
      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
      expect(location).toContain('error=')
    })
  })

  describe('Security Validations - Email Domain Restriction', () => {
    it('should reject unauthorized email domain', async () => {
      // Test business logic: Only allowed email domains can authenticate
      const unauthorizedEmail = SAMLTestScenarios.unauthorizedDomain.email
      const samlResponse = SAMLResponseFactory.valid(unauthorizedEmail)

      const response = await postSAMLCallback(samlResponse)

      // Should fail due to domain restriction
      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
      // Note: Might need to adjust based on actual error code returned
    })
  })

  describe('Security Validations - User Pre-provisioning', () => {
    it('should reject SAML response for non-provisioned user', async () => {
      // Test business requirement: Users must be pre-provisioned
      const nonExistentEmail = 'not.provisioned@bendcare.com'
      const samlResponse = SAMLResponseFactory.valid(nonExistentEmail)

      const response = await postSAMLCallback(samlResponse)

      // Should redirect with user_not_provisioned error
      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
      expect(location).toContain('error=user_not_provisioned')
    })

    it('should reject SAML response for inactive user', async () => {
      // Test security: Inactive users cannot authenticate
      const inactiveUser = await createTestUser({
        email: 'inactive@bendcare.com',
        is_active: false
      })

      const samlResponse = SAMLResponseFactory.valid(inactiveUser.email)
      const response = await postSAMLCallback(samlResponse)

      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
      expect(location).toContain('error=user_inactive')
    })
  })

  describe('Input Sanitization - Injection Prevention', () => {
    it('should sanitize SQL injection attempts in display name', async () => {
      // Test defense-in-depth: Sanitize malicious inputs
      const sqlInjection = SAMLTestScenarios.sqlInjection
      const samlResponse = SAMLResponseFactory.withAttributes(testUser.email, {
        displayName: sqlInjection.displayName,
        givenName: sqlInjection.givenName
      })

      const response = await postSAMLCallback(samlResponse)

      // Should reject or sanitize the input
      // The input validator should catch dangerous characters
      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
    })

    it('should sanitize XSS attempts in SAML attributes', async () => {
      // Test XSS prevention
      const xssAttack = SAMLTestScenarios.xssAttack
      const samlResponse = SAMLResponseFactory.withAttributes(testUser.email, {
        displayName: xssAttack.displayName,
        givenName: xssAttack.givenName
      })

      const response = await postSAMLCallback(samlResponse)

      // Should reject or sanitize
      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
    })

    it('should handle extremely long attribute values', async () => {
      // Test DoS prevention via length validation
      const veryLongName = 'A'.repeat(1000)
      const samlResponse = SAMLResponseFactory.withAttributes(testUser.email, {
        displayName: veryLongName
      })

      const response = await postSAMLCallback(samlResponse)

      // Should reject or truncate
      expect(response.status).toBe(302)
    })
  })

  describe('Error Handling', () => {
    it('should handle missing SAMLResponse parameter', async () => {
      const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:4001'

      const response = await fetch(`${baseUrl}/api/auth/saml/callback`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: '' // No SAMLResponse
      })

      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
      expect(location).toContain('error=')
    })

    it('should handle malformed SAMLResponse', async () => {
      const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:4001'

      const response = await fetch(`${baseUrl}/api/auth/saml/callback`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: 'SAMLResponse=INVALID_BASE64_DATA'
      })

      expect(response.status).toBe(302)
      const location = response.headers.get('location')
      expect(location).toContain('/signin')
    })
  })

  describe('Rate Limiting', () => {
    it('should enforce rate limiting on callback endpoint', async () => {
      // Test security: Prevent brute force attacks
      const samlResponse = SAMLResponseFactory.valid(testUser.email)

      // Make multiple rapid requests
      const requests = Array(10).fill(null).map(() =>
        postSAMLCallback(samlResponse)
      )

      const responses = await Promise.all(requests)

      // Some requests should be rate limited
      // Note: Actual rate limit enforcement depends on configuration
      const statusCodes = responses.map(r => r.status)

      // At least verify all requests completed
      expect(statusCodes.length).toBe(10)
    })
  })
})
