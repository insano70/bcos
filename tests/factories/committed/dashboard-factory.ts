/**
 * Committed Dashboard Factory
 *
 * Creates dashboards in committed transactions that are visible to services
 * using the global db connection.
 *
 * This factory:
 * - Generates cryptographically unique test dashboard IDs
 * - Creates dashboards visible to all database connections
 * - Tracks dashboards for automatic cleanup
 * - Supports bulk dashboard creation
 * - Automatically tracks user dependencies
 */

import type { InferSelectModel } from 'drizzle-orm';
import { inArray } from 'drizzle-orm';
import { dashboards } from '@/lib/db/schema';
import {
  BaseFactory,
  type BaseFactoryOptions,
  defaultCleanupTracker,
  defaultIDGenerator,
} from '../base';

/**
 * Dashboard data type from database schema
 */
export type CommittedDashboard = InferSelectModel<typeof dashboards>;

/**
 * Options for creating a test dashboard
 */
export interface CreateDashboardOptions extends BaseFactoryOptions {
  /**
   * Dashboard name
   * If not provided, a unique name will be generated
   */
  dashboard_name?: string;

  /**
   * Dashboard description
   */
  dashboard_description?: string;

  /**
   * Dashboard category ID
   */
  dashboard_category_id?: number;

  /**
   * Layout configuration as JSON
   * Defaults to empty object
   */
  layout_config?: Record<string, unknown>;

  /**
   * Whether the dashboard is active
   * Defaults to true
   */
  is_active?: boolean;

  /**
   * Whether the dashboard is published
   * Defaults to false
   */
  is_published?: boolean;

  /**
   * User ID who creates the dashboard (REQUIRED)
   * Must be a valid user ID (can use createCommittedUser to create one)
   */
  created_by: string;
}

/**
 * Dashboard Factory
 *
 * Creates test dashboards in committed transactions.
 *
 * @example
 * ```typescript
 * const factory = new CommittedDashboardFactory()
 *
 * // Create a user first (dashboards require a creator)
 * const user = await createCommittedUser({ scope: 'my-test' })
 *
 * // Create a dashboard
 * const { data: dashboard } = await factory.create({
 *   dashboard_name: 'My Dashboard',
 *   created_by: user.user_id,
 *   scope: 'my-test'
 * })
 *
 * // Create multiple dashboards
 * const dashboards = await factory.createMany(5, {
 *   created_by: user.user_id,
 *   scope: 'my-test'
 * })
 *
 * // Cleanup (dashboards cleaned before users due to foreign key)
 * await factory.cleanup('my-test')
 * ```
 */
export class CommittedDashboardFactory extends BaseFactory<
  CommittedDashboard,
  CreateDashboardOptions
> {
  protected readonly entityType = 'dashboard' as const;

  /**
   * Create a dashboard in the database
   * Database will generate dashboard_id UUID automatically
   */
  protected async createInDatabase(options: CreateDashboardOptions): Promise<CommittedDashboard> {
    if (!options.created_by) {
      throw new Error(
        'created_by is required for dashboard creation. ' +
          'Use createCommittedUser() to create a user first.'
      );
    }

    // Generate unique dashboard name if not provided
    const dashboardName = options.dashboard_name || this.generateTestName('Dashboard');

    const dashboardData = {
      // dashboard_id will be generated by database (defaultRandom())
      dashboard_name: dashboardName,
      dashboard_description: options.dashboard_description ?? undefined,
      dashboard_category_id: options.dashboard_category_id ?? undefined,
      layout_config: options.layout_config || {},
      is_active: options.is_active ?? true,
      is_published: options.is_published ?? false,
      created_by: options.created_by,
    };

    const [dashboard] = await this.db.insert(dashboards).values(dashboardData).returning();

    if (!dashboard) {
      throw new Error(`Failed to create test dashboard`);
    }

    return dashboard;
  }

  /**
   * Clean up dashboards from the database
   */
  protected async cleanupFromDatabase(ids: string[]): Promise<void> {
    if (ids.length === 0) {
      return;
    }

    await this.db.delete(dashboards).where(inArray(dashboards.dashboard_id, ids));
  }

  /**
   * Track dashboard dependencies (user who created it)
   */
  protected override trackDependencies(id: string, data: CommittedDashboard): void {
    // Dashboard depends on its creator - always track since UUIDs are DB-generated
    if (data.created_by) {
      this.cleanupTracker.addDependency(id, data.created_by);
    }

    // Call parent implementation for other standard FK fields
    super.trackDependencies(id, data);
  }

  /**
   * Modify options for batch creation
   * Ensures each dashboard gets a unique name
   */
  protected override async modifyOptionsForBatch(
    baseOptions: CreateDashboardOptions,
    index: number,
    _total: number
  ): Promise<CreateDashboardOptions> {
    const name = baseOptions.dashboard_name
      ? `${baseOptions.dashboard_name} ${index + 1}`
      : undefined;

    return {
      ...baseOptions,
      ...(name ? { dashboard_name: name } : {}),
    };
  }

  /**
   * Validate options before creation
   */
  protected override async beforeCreate(
    options: CreateDashboardOptions
  ): Promise<CreateDashboardOptions | undefined> {
    if (!options.created_by) {
      throw new Error(
        'Dashboard creation requires created_by field. ' +
          'Create a user first with createCommittedUser().'
      );
    }

    // Ensure created_by is a valid ID format
    if (!options.created_by.startsWith('test_') && process.env.NODE_ENV === 'test') {
      console.warn(
        `Warning: Dashboard created_by (${options.created_by}) does not look like a test ID. ` +
          `This may cause issues with cleanup.`
      );
    }

    return options;
  }
}

/**
 * Create a singleton instance for convenience
 */
export const committedDashboardFactory = new CommittedDashboardFactory(
  defaultIDGenerator,
  defaultCleanupTracker
);

/**
 * Convenience function to create a dashboard
 * Uses the singleton factory instance
 *
 * @example
 * ```typescript
 * const user = await createCommittedUser()
 * const dashboard = await createCommittedDashboard({
 *   dashboard_name: 'My Dashboard',
 *   created_by: user.user_id,
 *   scope: 'my-test'
 * })
 * ```
 */
export async function createCommittedDashboard(
  options: CreateDashboardOptions
): Promise<CommittedDashboard> {
  const result = await committedDashboardFactory.create(options);
  return result.data;
}

/**
 * Convenience function to create multiple dashboards
 * Uses the singleton factory instance
 *
 * @example
 * ```typescript
 * const user = await createCommittedUser()
 * const dashboards = await createCommittedDashboards(5, {
 *   created_by: user.user_id,
 *   scope: 'my-test'
 * })
 * ```
 */
export async function createCommittedDashboards(
  count: number,
  options: CreateDashboardOptions
): Promise<CommittedDashboard[]> {
  const results = await committedDashboardFactory.createMany(count, options);
  return results.map((r) => r.data);
}

/**
 * Convenience function to cleanup dashboards
 * Uses the singleton factory instance
 *
 * @example
 * ```typescript
 * await cleanupCommittedDashboards('my-test')
 * ```
 */
export async function cleanupCommittedDashboards(scope?: string): Promise<number> {
  return await committedDashboardFactory.cleanup(scope);
}
