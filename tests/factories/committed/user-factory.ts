/**
 * Committed User Factory
 *
 * Creates users in committed transactions that are visible to services
 * using the global db connection.
 *
 * This factory:
 * - Generates cryptographically unique test user IDs
 * - Creates users visible to all database connections
 * - Tracks users for automatic cleanup
 * - Supports bulk user creation
 * - Handles password hashing automatically
 */

import { users } from '@/lib/db/schema'
import { hashPassword } from '@/lib/auth/password'
import { inArray } from 'drizzle-orm'
import { generateUniqueEmail } from '@/tests/helpers/unique-generator'
import {
  BaseFactory,
  defaultIDGenerator,
  defaultCleanupTracker,
  type BaseFactoryOptions
} from '../base'
import type { InferSelectModel } from 'drizzle-orm'

/**
 * User data type from database schema
 */
export type CommittedUser = InferSelectModel<typeof users>

/**
 * Options for creating a test user
 */
export interface CreateUserOptions extends BaseFactoryOptions {
  /**
   * User's email address
   * If not provided, a unique email will be generated
   */
  email?: string

  /**
   * User's password (will be hashed automatically)
   * Defaults to 'TestPassword123!'
   */
  password?: string

  /**
   * User's first name
   * Defaults to 'Test'
   */
  firstName?: string

  /**
   * User's last name
   * Defaults to 'User'
   */
  lastName?: string

  /**
   * Whether the email is verified
   * Defaults to false
   */
  emailVerified?: boolean

  /**
   * Whether the user is active
   * Defaults to true
   */
  isActive?: boolean
}

/**
 * User Factory
 *
 * Creates test users in committed transactions.
 *
 * @example
 * ```typescript
 * const factory = new CommittedUserFactory()
 *
 * // Create a single user
 * const { data: user } = await factory.create({
 *   email: 'test@example.com',
 *   firstName: 'John'
 * })
 *
 * // Create multiple users
 * const users = await factory.createMany(5, {
 *   scope: 'my-test'
 * })
 *
 * // Cleanup
 * await factory.cleanup('my-test')
 * ```
 */
export class CommittedUserFactory extends BaseFactory<CommittedUser, CreateUserOptions> {
  protected readonly entityType = 'user' as const

  /**
   * Create a user in the database
   * Database will generate user_id UUID automatically
   */
  protected async createInDatabase(
    options: CreateUserOptions
  ): Promise<CommittedUser> {
    const passwordHash = await hashPassword(options.password || 'TestPassword123!')

    // Generate unique email if not provided
    const email = options.email || generateUniqueEmail()

    const userData = {
      // user_id will be generated by database (defaultRandom())
      email,
      password_hash: passwordHash,
      first_name: options.firstName || 'Test',
      last_name: options.lastName || 'User',
      email_verified: options.emailVerified ?? false,
      is_active: options.isActive ?? true
    }

    const [user] = await this.db.insert(users).values(userData).returning()

    if (!user) {
      throw new Error(`Failed to create test user`)
    }

    return user
  }

  /**
   * Clean up users from the database
   */
  protected async cleanupFromDatabase(ids: string[]): Promise<void> {
    if (ids.length === 0) {
      return
    }

    await this.db
      .delete(users)
      .where(inArray(users.user_id, ids))
  }

  /**
   * Modify options for batch creation
   * Ensures each user gets a unique email
   */
  protected override async modifyOptionsForBatch(
    baseOptions: CreateUserOptions,
    index: number,
    total: number
  ): Promise<CreateUserOptions> {
    // Ensure unique email for each user in batch
    const email = baseOptions.email
      ? `${baseOptions.email.split('@')[0]}_${index}@${baseOptions.email.split('@')[1]}`
      : generateUniqueEmail()

    return {
      ...baseOptions,
      email
    }
  }

  /**
   * Hook: Log when users are created (for debugging)
   */
  protected override async afterCreate(
    data: CommittedUser,
    options: CreateUserOptions
  ): Promise<void> {
    // Optional: Add logging or additional setup here
    // For now, this is a no-op but demonstrates the hook pattern
  }

  /**
   * Hook: Verify cleanup completed successfully
   */
  protected override async afterCleanup(ids: string[]): Promise<void> {
    // Optional: Verify users were deleted
    // Could query database to confirm deletion
  }
}

/**
 * Create a singleton instance for convenience
 */
export const committedUserFactory = new CommittedUserFactory(
  defaultIDGenerator,
  defaultCleanupTracker
)

/**
 * Convenience function to create a user
 * Uses the singleton factory instance
 *
 * @example
 * ```typescript
 * const user = await createCommittedUser({
 *   email: 'test@example.com',
 *   scope: 'my-test'
 * })
 * ```
 */
export async function createCommittedUser(
  options: CreateUserOptions = {}
): Promise<CommittedUser> {
  const result = await committedUserFactory.create(options)
  return result.data
}

/**
 * Convenience function to create multiple users
 * Uses the singleton factory instance
 *
 * @example
 * ```typescript
 * const users = await createCommittedUsers(5, {
 *   scope: 'my-test'
 * })
 * ```
 */
export async function createCommittedUsers(
  count: number,
  options: CreateUserOptions = {}
): Promise<CommittedUser[]> {
  const results = await committedUserFactory.createMany(count, options)
  return results.map(r => r.data)
}

/**
 * Convenience function to cleanup users
 * Uses the singleton factory instance
 *
 * @example
 * ```typescript
 * await cleanupCommittedUsers('my-test')
 * ```
 */
export async function cleanupCommittedUsers(scope?: string): Promise<number> {
  return await committedUserFactory.cleanup(scope)
}
