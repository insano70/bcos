name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: bcos
  ECS_SERVICE: bcos-production-service
  ECS_CLUSTER: bcos-production-cluster
  ECS_TASK_DEFINITION: bcos-production

concurrency:
  group: production-deployment
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  security-events: write
  deployments: write

jobs:
  # Pre-deployment Validation
  validate:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744 # v3.6.0
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="v$(date +%Y%m%d)-${GITHUB_SHA::8}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION}"

      - name: Check if deployment should proceed
        id: check
        run: |
          # Check if this is a valid production deployment
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Production deployments only allowed from main branch or manual trigger"
            exit 1
          fi

  # Testing removed - deploy directly after validation

  # Build Production Image
  build:
    runs-on: ubuntu-latest
    environment: production
    needs: [validate]
    if: needs.validate.outputs.should-deploy == 'true'
    timeout-minutes: 15
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.build.outputs.image-uri }}
    steps:
      - name: Checkout code
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-GitHubActionsDeploymentRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Production-Build-${{ github.run_number }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@818d4b7b91585d195f67373fd9cb0332e31a7175
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=raw,value=production-latest
            type=raw,value=${{ needs.validate.outputs.version }}
            type=sha,prefix=production-

      - name: Build and push container image
        id: build
        uses: docker/build-push-action@2eb1c1961a95fc15694676618e422e8ba1d63825
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=production
            NEXT_TELEMETRY_DISABLED=1
            BUILD_VERSION=${{ needs.validate.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64


      - name: Set outputs
        run: |
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.validate.outputs.version }}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

  # Production Deployment with Approval
  deploy:
    runs-on: ubuntu-latest
    environment: production
    needs: [validate, build]
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-GitHubActionsDeploymentRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Production-Deploy-${{ github.run_number }}

      - name: Create deployment
        id: deployment
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment of ${{ needs.validate.outputs.version }}',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Set deployment status to in progress
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'in_progress',
              description: 'Deployment in progress'
            });

      - name: Get current task definition
        run: |
          aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json

      - name: Update ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@4225e0b507142a2e432b018bc3ccb728559b437a
        with:
          task-definition: task-definition.json
          container-name: bcos
          image: ${{ needs.build.outputs.image-uri }}

      - name: Deploy to ECS
        id: ecs-deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@df9643053eda01f169e64a0e60233aacca83799a
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Verify production deployment
        id: verify
        run: |
          echo "üîç Verifying production deployment..."
          sleep 90  # Allow time for deployment to stabilize
          
          # Health check
          HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://app.bendcare.com/health || echo "000")
          
          # API check
          API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://app.bendcare.com/api/health || echo "000")
          
          echo "Health endpoint: $HEALTH_RESPONSE"
          echo "API endpoint: $API_RESPONSE"
          
          if [ "$HEALTH_RESPONSE" -eq 200 ] && [ "$API_RESPONSE" -eq 200 ]; then
            echo "‚úÖ Production deployment verified successfully"
            echo "deployment-status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Production deployment verification failed"
            echo "deployment-status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Set deployment status to success
        if: steps.verify.outputs.deployment-status == 'success'
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              description: 'Production deployment successful',
              environment_url: 'https://app.bendcare.com'
            });

      - name: Set deployment status to failure
        if: failure()
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Production deployment failed'
            });

      - name: Post-deployment summary
        if: always()
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.validate.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: https://app.bendcare.com" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring**: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-production-Dashboard" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service**: https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_REGION }}#/clusters/${{ env.ECS_CLUSTER }}/services/${{ env.ECS_SERVICE }}/details" >> $GITHUB_STEP_SUMMARY

  # Post-deployment monitoring
  monitor:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()
    timeout-minutes: 10
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-GitHubActionsDeploymentRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Production-Monitor-${{ github.run_number }}

      - name: Check service metrics
        run: |
          echo "üìä Checking production service metrics..."
          
          # Check ECS service status
          SERVICE_STATUS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --query 'services[0].status' --output text)
          RUNNING_COUNT=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --query 'services[0].runningCount' --output text)
          DESIRED_COUNT=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --query 'services[0].desiredCount' --output text)
          
          echo "Service Status: $SERVICE_STATUS"
          echo "Running Tasks: $RUNNING_COUNT / $DESIRED_COUNT"
          
          if [ "$SERVICE_STATUS" != "ACTIVE" ] || [ "$RUNNING_COUNT" -lt "$DESIRED_COUNT" ]; then
            echo "‚ö†Ô∏è Service not fully healthy, monitoring for improvements..."
          else
            echo "‚úÖ Service is healthy and running normally"
          fi
