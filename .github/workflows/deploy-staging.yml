name: Deploy Application

on:
  push:
    branches: [staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      branch:
        description: 'Branch to deploy (leave empty for current branch)'
        required: false
        type: string
      force_deploy:
        description: 'Force deployment even if checks fail'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: bcos

concurrency:
  group: staging-deployment-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  security-events: write

jobs:
  # Security scan and tests removed for fast staging deployments
  # Run security scans and tests locally before pushing to staging
  # OIDC trust policy updated with permissive conditions for insano70/bcos repository

  # Build and Deploy
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'staging' }}
    if: ${{ !failure() || github.event.inputs.force_deploy == 'true' }}
    timeout-minutes: 20
    steps:
      - name: Set deployment variables
        id: vars
        run: |
          # Determine target environment
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "TARGET_ENV=production" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-production-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-production-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-production" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=production-${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "TARGET_ENV=staging" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-staging-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-staging-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-staging" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=staging-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi
          
          # Determine branch to deploy
          if [ -n "${{ github.event.inputs.branch }}" ]; then
            echo "DEPLOY_BRANCH=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
          else
            echo "DEPLOY_BRANCH=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744
        with:
          ref: ${{ steps.vars.outputs.DEPLOY_BRANCH }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-GitHubActionsDeploymentRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-${{ steps.vars.outputs.TARGET_ENV }}-${{ github.run_number }}
          mask-aws-account-id: false

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2.0.1

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@818d4b7b91585d195f67373fd9cb0332e31a7175 # v4.6.0
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=raw,value=${{ steps.vars.outputs.IMAGE_TAG }}
            type=raw,value=${{ steps.vars.outputs.TARGET_ENV }}-latest

      - name: Build and push container image
        id: build-image
        uses: docker/build-push-action@2eb1c1961a95fc15694676618e422e8ba1d63825 # v4.1.1
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=production
            NEXT_TELEMETRY_DISABLED=1
            BUILD_VERSION=${{ steps.vars.outputs.IMAGE_TAG }}
          platforms: linux/amd64



      - name: Get current task definition and fix health check
        run: |
          if aws ecs describe-task-definition --task-definition ${{ steps.vars.outputs.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json 2>/dev/null; then
            echo "‚úÖ Existing task definition found, fixing health check path"
            # Fix health check path from /health to /api/health (CDK handles all secrets)
            jq '.containerDefinitions[0].healthCheck.command[1] = "curl -f http://localhost:3000/api/health || exit 1"' task-definition.json > task-definition-fixed.json
            mv task-definition-fixed.json task-definition.json
          else
            echo "‚ö†Ô∏è No existing task definition found, creating minimal one"
            cat > task-definition.json << EOF
          {
            "family": "${{ steps.vars.outputs.ECS_TASK_DEFINITION }}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-ECSTaskExecutionRole",
            "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-ECSTaskRole",
            "containerDefinitions": [
              {
                "name": "bcos",
                "image": "placeholder:latest",
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "hostPort": 3000,
                    "protocol": "tcp",
                    "name": "http"
                  }
                ],
                "essential": true,
                "healthCheck": {
                  "command": [
                    "CMD-SHELL",
                    "curl -f http://localhost:3000/api/health || exit 1"
                  ],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                },
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/bcos-${{ steps.vars.outputs.TARGET_ENV }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ]
          }
          EOF
          fi

      - name: Update ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@4225e0b507142a2e432b018bc3ccb728559b437a # v1.2.0
        with:
          task-definition: task-definition.json
          container-name: bcos
          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.IMAGE_TAG }}

      - name: Ensure CloudWatch log group exists
        run: |
          LOG_GROUP="/ecs/bcos-${{ steps.vars.outputs.TARGET_ENV }}"
          if ! aws logs describe-log-groups --log-group-name-prefix "${LOG_GROUP}" --query 'logGroups[?logGroupName==`'${LOG_GROUP}'`]' --output text | grep -q "${LOG_GROUP}"; then
            echo "Creating log group: ${LOG_GROUP}"
            aws logs create-log-group --log-group-name "${LOG_GROUP}"
            aws logs put-retention-policy --log-group-name "${LOG_GROUP}" --retention-in-days 30
          else
            echo "‚úÖ Log group already exists: ${LOG_GROUP}"
          fi

      - name: Register task definition
        id: register-task-def
        run: |
          # Clean task definition JSON by removing read-only fields
          CLEAN_TASK_DEF=$(cat ${{ steps.task-def.outputs.task-definition }} | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy, .placementConstraints)')
          echo "${CLEAN_TASK_DEF}" > clean-task-definition.json
          
          # Register the cleaned task definition
          TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://clean-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "task-definition-arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT
          echo "‚úÖ Task definition registered: ${TASK_DEF_ARN}"

      - name: Check if ECS service exists
        id: check-service
        run: |
          if aws ecs describe-services --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --services ${{ steps.vars.outputs.ECS_SERVICE }} --query 'services[?status!=`INACTIVE`]' --output text 2>/dev/null | grep -q .; then
            echo "service-exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Service exists and is active"
          else
            echo "service-exists=false" >> $GITHUB_OUTPUT  
            echo "‚ö†Ô∏è Service does not exist or is inactive"
          fi

      - name: Create ECS service (if it doesn't exist)  
        if: steps.check-service.outputs.service-exists == 'false'
        run: |
          # Get target group ARN from CDK stack outputs
          TARGET_GROUP_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-StagingStack --query 'Stacks[0].Outputs[?OutputKey==`StagingTargetGroupArn`].OutputValue' --output text)
          echo "üéØ Target Group ARN: ${TARGET_GROUP_ARN}"
          
          # Get network configuration from CloudFormation exports
          PRIVATE_SUBNETS=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnetIds`].OutputValue' --output text)
          ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroupId`].OutputValue' --output text)
          echo "üîó Private Subnets: ${PRIVATE_SUBNETS}"
          echo "üõ°Ô∏è  ECS Security Group: ${ECS_SECURITY_GROUP}"
          
          # Create ECS service with proper load balancer configuration
          echo "üöÄ Creating ECS service: ${{ steps.vars.outputs.ECS_SERVICE }}"
          aws ecs create-service \
            --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
            --service-name ${{ steps.vars.outputs.ECS_SERVICE }} \
            --task-definition ${{ steps.register-task-def.outputs.task-definition-arn }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNETS}],securityGroups=[${ECS_SECURITY_GROUP}],assignPublicIp=DISABLED}" \
            --load-balancers "targetGroupArn=${TARGET_GROUP_ARN},containerName=bcos,containerPort=3000" \
            --health-check-grace-period-seconds 300 \
            --deployment-configuration "maximumPercent=200,minimumHealthyPercent=50" \
            --enable-execute-command
          
          echo "‚úÖ ECS service created successfully: ${{ steps.vars.outputs.ECS_SERVICE }}"

      - name: Deploy to ECS
        run: |
          # Check if service was just created or already exists
          if [ "${{ steps.check-service.outputs.service-exists }}" == "false" ]; then
            echo "üéâ Service was just created, waiting for initial deployment..."
          else
            echo "üîÑ Updating existing service with new task definition..."
            aws ecs update-service \
              --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
              --service ${{ steps.vars.outputs.ECS_SERVICE }} \
              --task-definition ${{ steps.register-task-def.outputs.task-definition-arn }}
          fi
          
          # Wait for service stability
          echo "‚è≥ Waiting for service to reach steady state..."
          aws ecs wait services-stable \
            --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
            --services ${{ steps.vars.outputs.ECS_SERVICE }}
          
          echo "‚úÖ ECS deployment completed successfully"

      - name: Verify deployment
        run: |
          # Wait for deployment to complete (Next.js apps need more startup time)
          sleep 120
          
          # Set health check URL based on environment
          if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
            HEALTH_URL="https://app.bendcare.com/api/health"
            APP_URL="https://app.bendcare.com"
          else
            HEALTH_URL="https://staging.bendcare.com/api/health"
            APP_URL="https://staging.bendcare.com"
          fi
          
          # Health check
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)
          if [ "$RESPONSE" -eq 200 ]; then
            echo "‚úÖ ${{ steps.vars.outputs.TARGET_ENV }} deployment successful - Health check passed"
          else
            echo "‚ùå ${{ steps.vars.outputs.TARGET_ENV }} deployment failed - Health check returned: $RESPONSE"
            exit 1
          fi

      - name: Update deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ ${{ steps.vars.outputs.TARGET_ENV }} deployment completed successfully"
            if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
              echo "üåê Application URL: https://app.bendcare.com"
              echo "üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-production-Dashboard"
            else
              echo "üåê Application URL: https://staging.bendcare.com"
              echo "üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-staging-Dashboard"
            fi
          else
            echo "‚ùå ${{ steps.vars.outputs.TARGET_ENV }} deployment failed"
            echo "üîç Check logs: https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_REGION }}#/clusters/${{ steps.vars.outputs.ECS_CLUSTER }}/services/${{ steps.vars.outputs.ECS_SERVICE }}/logs"
          fi
