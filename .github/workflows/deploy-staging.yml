name: Deploy Application

on:
  push:
    branches: [staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      branch:
        description: 'Branch to deploy (leave empty for current branch)'
        required: false
        type: string
      force_deploy:
        description: 'Force deployment even if checks fail'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: bcos

concurrency:
  group: staging-deployment-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  security-events: write

jobs:
  # Security scan and tests removed for fast staging deployments
  # Run security scans and tests locally before pushing to staging
  # OIDC trust policy updated with permissive conditions for insano70/bcos repository

  # Build and Deploy
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'staging' }}
    if: ${{ !failure() || github.event.inputs.force_deploy == 'true' }}
    timeout-minutes: 20
    steps:
      - name: Set deployment variables
        id: vars
        run: |
          # Determine target environment
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "TARGET_ENV=production" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-production-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-production-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-production" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=production-${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "TARGET_ENV=staging" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-staging-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-staging-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-staging" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=staging-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi
          
          # Determine branch to deploy
          if [ -n "${{ github.event.inputs.branch }}" ]; then
            echo "DEPLOY_BRANCH=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
          else
            echo "DEPLOY_BRANCH=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744
        with:
          ref: ${{ steps.vars.outputs.DEPLOY_BRANCH }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-GitHubActionsDeploymentRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-${{ steps.vars.outputs.TARGET_ENV }}-${{ github.run_number }}
          mask-aws-account-id: false

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2.0.1

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@818d4b7b91585d195f67373fd9cb0332e31a7175 # v4.6.0
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=raw,value=${{ steps.vars.outputs.IMAGE_TAG }}
            type=raw,value=${{ steps.vars.outputs.TARGET_ENV }}-latest

      - name: Build and push container image
        id: build-image
        uses: docker/build-push-action@2eb1c1961a95fc15694676618e422e8ba1d63825 # v4.1.1
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=production
            NEXT_TELEMETRY_DISABLED=1
            BUILD_VERSION=${{ steps.vars.outputs.IMAGE_TAG }}
          platforms: linux/amd64



      - name: Get current task definition and fix health check
        run: |
          # Debug: Show what task definition version we're starting with
          echo "üîç DEBUG: Current task definition before workflow:"
          if CURRENT_ARN=$(aws ecs describe-task-definition --task-definition ${{ steps.vars.outputs.ECS_TASK_DEFINITION }} --query 'taskDefinition.taskDefinitionArn' --output text 2>/dev/null); then
            CURRENT_VERSION=$(echo "${CURRENT_ARN}" | sed 's/.*://')
            echo "üìã CURRENT VERSION BEFORE WORKFLOW: ${CURRENT_VERSION}"
            echo "üìã CURRENT ARN: ${CURRENT_ARN}"
          else
            echo "‚ùå No existing task definition found"
          fi
          
          if aws ecs describe-task-definition --task-definition ${{ steps.vars.outputs.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json 2>/dev/null; then
            echo "‚úÖ Existing task definition found, fixing health check path"
            # Fix health check path from /health to /api/health (CDK handles all secrets)
            jq '.containerDefinitions[0].healthCheck.command[1] = "curl -f http://localhost:3000/api/health || exit 1"' task-definition.json > task-definition-fixed.json
            mv task-definition-fixed.json task-definition.json
          else
            echo "‚ö†Ô∏è No existing task definition found, creating minimal one"
            cat > task-definition.json << EOF
          {
            "family": "${{ steps.vars.outputs.ECS_TASK_DEFINITION }}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-ECSTaskExecutionRole",
            "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-ECSTaskRole",
            "containerDefinitions": [
              {
                "name": "bcos",
                "image": "placeholder:latest",
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "hostPort": 3000,
                    "protocol": "tcp",
                    "name": "http"
                  }
                ],
                "essential": true,
                "healthCheck": {
                  "command": [
                    "CMD-SHELL",
                    "curl -f http://localhost:3000/api/health || exit 1"
                  ],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                },
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/bcos-${{ steps.vars.outputs.TARGET_ENV }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ]
          }
          EOF
          fi

      - name: Update ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@4225e0b507142a2e432b018bc3ccb728559b437a # v1.2.0
        with:
          task-definition: task-definition.json
          container-name: bcos
          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.IMAGE_TAG }}

      - name: Ensure CloudWatch log group exists
        run: |
          LOG_GROUP="/ecs/bcos-${{ steps.vars.outputs.TARGET_ENV }}"
          if ! aws logs describe-log-groups --log-group-name-prefix "${LOG_GROUP}" --query 'logGroups[?logGroupName==`'${LOG_GROUP}'`]' --output text | grep -q "${LOG_GROUP}"; then
            echo "Creating log group: ${LOG_GROUP}"
            aws logs create-log-group --log-group-name "${LOG_GROUP}"
            aws logs put-retention-policy --log-group-name "${LOG_GROUP}" --retention-in-days 30
          else
            echo "‚úÖ Log group already exists: ${LOG_GROUP}"
          fi

      - name: Register task definition
        id: register-task-def
        run: |
          # Debug: Check what we got from aws-actions step
          echo "üîç DEBUG: Task definition file from aws-actions step:"
          if [ -f "${{ steps.task-def.outputs.task-definition }}" ]; then
            echo "‚úÖ Task definition file exists: ${{ steps.task-def.outputs.task-definition }}"
            echo "üìÑ Current family/revision in file:"
            jq -r '.family + ":" + (.revision // "no-revision" | tostring)' "${{ steps.task-def.outputs.task-definition }}"
            
            # CRITICAL DEBUG: Check if aws-actions output contains any ARN
            if jq -e '.taskDefinitionArn' "${{ steps.task-def.outputs.task-definition }}" >/dev/null 2>&1; then
              EXISTING_ARN=$(jq -r '.taskDefinitionArn' "${{ steps.task-def.outputs.task-definition }}")
              EXISTING_VERSION=$(echo "${EXISTING_ARN}" | sed 's/.*://')
              echo "‚ö†Ô∏è  WARNING: aws-actions output contains ARN: ${EXISTING_ARN} (version ${EXISTING_VERSION})"
              echo "üîç This ARN will be REMOVED before registration"
            else
              echo "‚úÖ No ARN found in aws-actions output (good)"
            fi
          else
            echo "‚ùå Task definition file missing: ${{ steps.task-def.outputs.task-definition }}"
            exit 1
          fi
          
          # Clean task definition JSON by removing read-only fields
          echo "üßπ Cleaning task definition by removing read-only fields..."
          CLEAN_TASK_DEF=$(cat ${{ steps.task-def.outputs.task-definition }} | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy, .placementConstraints)')
          echo "${CLEAN_TASK_DEF}" > clean-task-definition.json
          
          # Debug: Verify cleaned task definition has no ARN
          if jq -e '.taskDefinitionArn' clean-task-definition.json >/dev/null 2>&1; then
            echo "‚ùå ERROR: Cleaned task definition still contains ARN!"
            jq -r '.taskDefinitionArn' clean-task-definition.json
            exit 1
          else
            echo "‚úÖ Cleaned task definition has no ARN (good)"
          fi
          
          # Debug: Show cleaned task definition family
          echo "üßπ Cleaned task definition family:"
          jq -r '.family' clean-task-definition.json
          
          # Register the cleaned task definition and capture the ARN
          echo "üìù Registering new task definition..."
          REGISTER_OUTPUT=$(aws ecs register-task-definition --cli-input-json file://clean-task-definition.json)
          TASK_DEF_ARN=$(echo "${REGISTER_OUTPUT}" | jq -r '.taskDefinition.taskDefinitionArn')
          
          # Verify we got a valid ARN
          if [ -z "${TASK_DEF_ARN}" ] || [ "${TASK_DEF_ARN}" == "null" ]; then
            echo "‚ùå ERROR: Failed to get task definition ARN from registration"
            echo "Register output: ${REGISTER_OUTPUT}"
            exit 1
          fi
          
          # Set output and display results
          echo "task-definition-arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT
          echo "‚úÖ Task definition registered: ${TASK_DEF_ARN}"
          
          # Debug: Extract and display version number
          TASK_DEF_VERSION=$(echo "${TASK_DEF_ARN}" | sed 's/.*://')
          echo "üè∑Ô∏è  NEW TASK DEFINITION VERSION: ${TASK_DEF_VERSION}"
          
          # CRITICAL DEBUG: Verify our output variable is set correctly
          echo "üîç DEBUG: Verifying output variable..."
          if [ -f "$GITHUB_OUTPUT" ]; then
            echo "üìã Contents of GITHUB_OUTPUT:"
            grep "task-definition-arn" "$GITHUB_OUTPUT" || echo "‚ùå task-definition-arn not found in GITHUB_OUTPUT"
          else
            echo "‚ùå GITHUB_OUTPUT file not found"
          fi

      - name: Check if ECS service exists
        id: check-service
        run: |
          if aws ecs describe-services --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --services ${{ steps.vars.outputs.ECS_SERVICE }} --query 'services[?status!=`INACTIVE`]' --output text 2>/dev/null | grep -q .; then
            echo "service-exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Service exists and is active"
          else
            echo "service-exists=false" >> $GITHUB_OUTPUT  
            echo "‚ö†Ô∏è Service does not exist or is inactive"
          fi

      - name: Create ECS service (if it doesn't exist)  
        if: steps.check-service.outputs.service-exists == 'false'
        run: |
          # Get target group ARN from CDK stack outputs
          TARGET_GROUP_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-StagingStack --query 'Stacks[0].Outputs[?OutputKey==`StagingTargetGroupArn`].OutputValue' --output text)
          echo "üéØ Target Group ARN: ${TARGET_GROUP_ARN}"
          
          # Get network configuration from CloudFormation exports
          PRIVATE_SUBNETS=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnetIds`].OutputValue' --output text)
          ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroupId`].OutputValue' --output text)
          echo "üîó Private Subnets: ${PRIVATE_SUBNETS}"
          echo "üõ°Ô∏è  ECS Security Group: ${ECS_SECURITY_GROUP}"
          
          # Create ECS service with proper load balancer configuration
          echo "üöÄ Creating ECS service: ${{ steps.vars.outputs.ECS_SERVICE }}"
          aws ecs create-service \
            --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
            --service-name ${{ steps.vars.outputs.ECS_SERVICE }} \
            --task-definition ${{ steps.register-task-def.outputs.task-definition-arn }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNETS}],securityGroups=[${ECS_SECURITY_GROUP}],assignPublicIp=DISABLED}" \
            --load-balancers "targetGroupArn=${TARGET_GROUP_ARN},containerName=bcos,containerPort=3000" \
            --health-check-grace-period-seconds 300 \
            --deployment-configuration "maximumPercent=200,minimumHealthyPercent=50" \
            --enable-execute-command
          
          echo "‚úÖ ECS service created successfully: ${{ steps.vars.outputs.ECS_SERVICE }}"

      - name: Deploy to ECS
        run: |
          # CRITICAL DEBUG: Verify what ARN we're about to use
          echo "üîç CRITICAL DEBUG: Task definition ARN for deployment:"
          DEPLOY_ARN="${{ steps.register-task-def.outputs.task-definition-arn }}"
          echo "üìã Raw ARN from step output: ${DEPLOY_ARN}"
          
          # Validate the ARN format and extract version
          if [[ "${DEPLOY_ARN}" =~ ^arn:aws:ecs:.*:task-definition/.*:([0-9]+)$ ]]; then
            DEPLOY_VERSION="${BASH_REMATCH[1]}"
            echo "üè∑Ô∏è  DEPLOYING VERSION: ${DEPLOY_VERSION}"
            echo "‚úÖ ARN format is valid"
          else
            echo "‚ùå ERROR: Invalid ARN format: ${DEPLOY_ARN}"
            echo "üîç Expected format: arn:aws:ecs:region:account:task-definition/family:version"
            exit 1
          fi
          
          # Double-check by querying the task definition to ensure it exists
          echo "üîç Verifying task definition exists..."
          if aws ecs describe-task-definition --task-definition "${DEPLOY_ARN}" --query 'taskDefinition.taskDefinitionArn' --output text >/dev/null 2>&1; then
            echo "‚úÖ Task definition confirmed to exist in AWS"
          else
            echo "‚ùå ERROR: Task definition does not exist in AWS!"
            echo "üîç ARN being checked: ${DEPLOY_ARN}"
            exit 1
          fi
          
          # Check if service was just created or already exists
          if [ "${{ steps.check-service.outputs.service-exists }}" == "false" ]; then
            echo "üéâ Service was just created, waiting for initial deployment..."
            echo "üîç Service will automatically use task definition: ${DEPLOY_ARN}"
          else
            echo "üîÑ Updating existing service with new task definition..."
            echo "üöÄ Command: aws ecs update-service --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --service ${{ steps.vars.outputs.ECS_SERVICE }} --task-definition ${DEPLOY_ARN}"
            
            # Execute the update command
            UPDATE_OUTPUT=$(aws ecs update-service \
              --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
              --service ${{ steps.vars.outputs.ECS_SERVICE }} \
              --task-definition "${DEPLOY_ARN}")
            
            # Verify what task definition the service is now using
            UPDATED_TASK_DEF=$(echo "${UPDATE_OUTPUT}" | jq -r '.service.taskDefinition')
            UPDATED_VERSION=$(echo "${UPDATED_TASK_DEF}" | sed 's/.*://')
            echo "üìã Service updated to use task definition: ${UPDATED_TASK_DEF}"
            echo "üè∑Ô∏è  Service now uses version: ${UPDATED_VERSION}"
            
            # Verify versions match
            if [ "${DEPLOY_VERSION}" == "${UPDATED_VERSION}" ]; then
              echo "‚úÖ SUCCESS: Deployed version matches expected version"
            else
              echo "‚ùå ERROR: Version mismatch!"
              echo "üéØ Expected: ${DEPLOY_VERSION}"
              echo "üéØ Actual: ${UPDATED_VERSION}"
              exit 1
            fi
          fi
          
          # Wait for service stability
          echo "‚è≥ Waiting for service to reach steady state..."
          aws ecs wait services-stable \
            --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
            --services ${{ steps.vars.outputs.ECS_SERVICE }}
          
          echo "‚úÖ ECS deployment completed successfully"
          
          # FINAL DEBUG: Comprehensive verification of what's actually running
          echo ""
          echo "üîç FINAL VERIFICATION: What task definition is actually running?"
          echo "=================================================="
          
          # Get service task definition
          if SERVICE_TASK_DEF=$(aws ecs describe-services --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --services ${{ steps.vars.outputs.ECS_SERVICE }} --query 'services[0].taskDefinition' --output text 2>/dev/null); then
            SERVICE_VERSION=$(echo "${SERVICE_TASK_DEF}" | sed 's/.*://')
            echo "üìã SERVICE shows task definition: ${SERVICE_TASK_DEF}"
            echo "üè∑Ô∏è  SERVICE version: ${SERVICE_VERSION}"
          else
            echo "‚ùå Could not retrieve service task definition"
            exit 1
          fi
          
          # Get actual running tasks
          echo ""
          echo "üîç Checking what tasks are actually running:"
          RUNNING_TASKS=$(aws ecs list-tasks --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --service-name ${{ steps.vars.outputs.ECS_SERVICE }} --desired-status RUNNING --query 'taskArns' --output text)
          
          if [ -n "${RUNNING_TASKS}" ] && [ "${RUNNING_TASKS}" != "None" ]; then
            echo "üèÉ Running tasks found, checking their task definitions:"
            for TASK_ARN in ${RUNNING_TASKS}; do
              TASK_DEF=$(aws ecs describe-tasks --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --tasks ${TASK_ARN} --query 'tasks[0].taskDefinitionArn' --output text)
              TASK_VERSION=$(echo "${TASK_DEF}" | sed 's/.*://')
              echo "  üìã Task ${TASK_ARN##*/} uses: ${TASK_DEF} (version ${TASK_VERSION})"
            done
          else
            echo "‚ö†Ô∏è  No running tasks found"
          fi
          
          # Final summary
          echo ""
          echo "üìä DEPLOYMENT SUMMARY:"
          echo "üéØ Expected version: ${DEPLOY_VERSION:-N/A}"
          echo "üìã Service version: ${SERVICE_VERSION}"
          echo "=================================================="

      - name: Verify deployment
        run: |
          # Wait for deployment to complete (Next.js apps need more startup time)
          sleep 120
          
          # Set health check URL based on environment
          if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
            HEALTH_URL="https://app.bendcare.com/api/health"
            APP_URL="https://app.bendcare.com"
          else
            HEALTH_URL="https://staging.bendcare.com/api/health"
            APP_URL="https://staging.bendcare.com"
          fi
          
          # Health check
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)
          if [ "$RESPONSE" -eq 200 ]; then
            echo "‚úÖ ${{ steps.vars.outputs.TARGET_ENV }} deployment successful - Health check passed"
          else
            echo "‚ùå ${{ steps.vars.outputs.TARGET_ENV }} deployment failed - Health check returned: $RESPONSE"
            exit 1
          fi

      - name: Update deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ ${{ steps.vars.outputs.TARGET_ENV }} deployment completed successfully"
            if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
              echo "üåê Application URL: https://app.bendcare.com"
              echo "üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-production-Dashboard"
            else
              echo "üåê Application URL: https://staging.bendcare.com"
              echo "üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-staging-Dashboard"
            fi
          else
            echo "‚ùå ${{ steps.vars.outputs.TARGET_ENV }} deployment failed"
            echo "üîç Check logs: https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_REGION }}#/clusters/${{ steps.vars.outputs.ECS_CLUSTER }}/services/${{ steps.vars.outputs.ECS_SERVICE }}/logs"
          fi
