name: Deploy Application (Unified)

on:
  push:
    branches: [staging, main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      branch:
        description: 'Branch to deploy (leave empty for current branch)'
        required: false
        type: string
      force_deploy:
        description: 'Force deployment even if checks fail'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: bcos

concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  security-events: write

jobs:
  # Security scan and tests removed for fast staging deployments
  # Run security scans and tests locally before pushing to staging
  # OIDC trust policy updated with permissive conditions for insano70/bcos repository

  # Build and Deploy
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
    if: ${{ !failure() || github.event.inputs.force_deploy == 'true' }}
    timeout-minutes: 20
    steps:
      - name: Set deployment variables
        id: vars
        run: |
          # Determine target environment based on branch or manual input
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "TARGET_ENV=production" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-production-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-production-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-production" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=production-${{ github.sha }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "TARGET_ENV=production" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-production-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-production-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-production" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=production-${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "TARGET_ENV=staging" >> $GITHUB_OUTPUT
            echo "ECS_SERVICE=bcos-staging-service" >> $GITHUB_OUTPUT
            echo "ECS_CLUSTER=bcos-staging-cluster" >> $GITHUB_OUTPUT
            echo "ECS_TASK_DEFINITION=bcos-staging" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=staging-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi
          
          # Determine branch to deploy
          if [ -n "${{ github.event.inputs.branch }}" ]; then
            echo "DEPLOY_BRANCH=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
          else
            echo "DEPLOY_BRANCH=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744
        with:
          ref: ${{ steps.vars.outputs.DEPLOY_BRANCH }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/BCOS-GitHubActionsDeploymentRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-${{ steps.vars.outputs.TARGET_ENV }}-${{ github.run_number }}
          mask-aws-account-id: false

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2.0.1

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@818d4b7b91585d195f67373fd9cb0332e31a7175 # v4.6.0
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=raw,value=${{ steps.vars.outputs.IMAGE_TAG }}
            type=raw,value=${{ steps.vars.outputs.TARGET_ENV }}-latest

      - name: Build and push container image
        id: build-image
        uses: docker/build-push-action@2eb1c1961a95fc15694676618e422e8ba1d63825 # v4.1.1
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=production
            NEXT_TELEMETRY_DISABLED=1
            BUILD_VERSION=${{ steps.vars.outputs.IMAGE_TAG }}
          platforms: linux/amd64

      - name: Ensure migration CloudWatch log group exists
        run: |
          MIGRATION_LOG_GROUP="/ecs/bcos-migrations-${{ steps.vars.outputs.TARGET_ENV }}"
          if ! aws logs describe-log-groups --log-group-name-prefix "${MIGRATION_LOG_GROUP}" --query 'logGroups[?logGroupName==`'${MIGRATION_LOG_GROUP}'`]' --output text | grep -q "${MIGRATION_LOG_GROUP}"; then
            echo "Creating migration log group: ${MIGRATION_LOG_GROUP}"
            aws logs create-log-group --log-group-name "${MIGRATION_LOG_GROUP}"
            aws logs put-retention-policy --log-group-name "${MIGRATION_LOG_GROUP}" --retention-in-days 30
          else
            echo "‚úÖ Migration log group already exists: ${MIGRATION_LOG_GROUP}"
          fi

      - name: Register migration task definition
        id: migration-task-def
        run: |
          # Get network configuration from CloudFormation exports
          PRIVATE_SUBNETS=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnetIds`].OutputValue' --output text)
          ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroupId`].OutputValue' --output text)
          
          # Get IAM role ARNs from CloudFormation exports
          EXECUTION_ROLE_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-SecurityStack --query 'Stacks[0].Outputs[?OutputKey==`ECSTaskExecutionRoleArn`].OutputValue' --output text)
          TASK_ROLE_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-SecurityStack --query 'Stacks[0].Outputs[?OutputKey==`ECSTaskRoleArn`].OutputValue' --output text)
          
          # Determine secret ARN based on environment
          if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
            SECRET_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-SecurityStack --query 'Stacks[0].Outputs[?OutputKey==`ProductionSecretArn`].OutputValue' --output text)
          else
            SECRET_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-SecurityStack --query 'Stacks[0].Outputs[?OutputKey==`StagingSecretArn`].OutputValue' --output text)
          fi
          
          # Create migration task definition JSON
          cat > migration-task-definition.json << EOF
          {
            "family": "bcos-migration-${{ steps.vars.outputs.TARGET_ENV }}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "${EXECUTION_ROLE_ARN}",
            "taskRoleArn": "${TASK_ROLE_ARN}",
            "containerDefinitions": [{
              "name": "migration-runner",
              "image": "${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.IMAGE_TAG }}",
              "command": ["npx", "tsx", "scripts/run-migrations.ts"],
              "essential": true,
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/bcos-migrations-${{ steps.vars.outputs.TARGET_ENV }}",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "migration"
                }
              },
              "secrets": [
                {
                  "name": "DATABASE_URL",
                  "valueFrom": "${SECRET_ARN}:DATABASE_URL::"
                }
              ],
              "environment": [
                {
                  "name": "NODE_ENV",
                  "value": "production"
                }
              ]
            }]
          }
          EOF
          
          # Register the task definition
          TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://migration-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "migration-task-def-arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT
          echo "‚úÖ Registered migration task definition: ${TASK_DEF_ARN}"

      - name: Warm up VPC endpoints
        run: |
          echo "üî• Warming up VPC endpoints..."
          # Make test calls to warm up interface VPC endpoints
          if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
            SECRET_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-SecurityStack --query 'Stacks[0].Outputs[?OutputKey==`ProductionSecretArn`].OutputValue' --output text)
          else
            SECRET_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-SecurityStack --query 'Stacks[0].Outputs[?OutputKey==`StagingSecretArn`].OutputValue' --output text)
          fi

          aws secretsmanager describe-secret --secret-id ${SECRET_ARN} > /dev/null || true
          echo "‚úÖ VPC endpoints warmed up"

      - name: Run database migrations
        run: |
          # Get network configuration from CloudFormation exports
          PRIVATE_SUBNETS=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnetIds`].OutputValue' --output text)
          ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroupId`].OutputValue' --output text)

          echo "üîÑ Running database migrations with retry logic..."
          echo "üìä Environment: ${{ steps.vars.outputs.TARGET_ENV }}"
          echo "üóÑÔ∏è  Using task definition: ${{ steps.migration-task-def.outputs.migration-task-def-arn }}"

          # Retry up to 3 times with 30-second delay between attempts
          MAX_ATTEMPTS=3
          ATTEMPT=1
          SUCCESS=false

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo ""
            echo "üîÑ Migration attempt $ATTEMPT of $MAX_ATTEMPTS..."

            # Run migration task
            TASK_ARN=$(aws ecs run-task \
              --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
              --task-definition ${{ steps.migration-task-def.outputs.migration-task-def-arn }} \
              --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNETS}],securityGroups=[${ECS_SECURITY_GROUP}],assignPublicIp=DISABLED}" \
              --launch-type FARGATE \
              --query 'tasks[0].taskArn' \
              --output text)

            echo "üìù Migration task started: ${TASK_ARN}"

            # Wait for migration task to complete (timeout after 10 minutes)
            echo "‚è≥ Waiting for migrations to complete..."
            aws ecs wait tasks-stopped --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --tasks ${TASK_ARN} --cli-read-timeout 600 || {
              echo "‚ö†Ô∏è  Wait command timed out or failed"
            }

            # Check migration task result
            TASK_INFO=$(aws ecs describe-tasks --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --tasks ${TASK_ARN})
            EXIT_CODE=$(echo "${TASK_INFO}" | jq -r '.tasks[0].containers[0].exitCode // "null"')
            STOPPED_REASON=$(echo "${TASK_INFO}" | jq -r '.tasks[0].stoppedReason // "Unknown"')
            LAST_STATUS=$(echo "${TASK_INFO}" | jq -r '.tasks[0].lastStatus')
            CONTAINER_REASON=$(echo "${TASK_INFO}" | jq -r '.tasks[0].containers[0].reason // "None"')

            echo "üìä Migration task status: ${LAST_STATUS}"
            echo "üî¢ Exit code: ${EXIT_CODE}"

            # Check for success (exit code 0)
            if [ "${EXIT_CODE}" = "0" ]; then
              echo "‚úÖ Database migrations completed successfully on attempt $ATTEMPT"
              SUCCESS=true
              break
            fi

            # Handle different failure scenarios
            if [ "${EXIT_CODE}" = "null" ]; then
              echo "‚ùå Migration task failed to start (ResourceInitializationError)"
              echo "Reason: ${STOPPED_REASON}"
              echo "Container reason: ${CONTAINER_REASON}"

              # Check if it's a retriable error
              if echo "${STOPPED_REASON}" | grep -qi "unable to retrieve secret\|connection issue\|context deadline exceeded\|rate limit.*network interface\|eni creation"; then
                echo "‚ö†Ô∏è  This appears to be a retriable initialization error"
                if echo "${STOPPED_REASON}" | grep -qi "rate limit"; then
                  echo "   (AWS rate limit on ENI creation - common during deployments)"
                elif echo "${STOPPED_REASON}" | grep -qi "unable to retrieve secret\|connection issue"; then
                  echo "   (VPC endpoint connection timeout)"
                fi
              else
                echo "‚ö†Ô∏è  This appears to be a non-retriable initialization error"
                echo ""
                echo "üìã Check migration logs at:"
                echo "https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fbcos-migrations-${{ steps.vars.outputs.TARGET_ENV }}"
                exit 1
              fi
            else
              echo "‚ùå Migration failed with exit code: ${EXIT_CODE}"
              echo "Reason: ${STOPPED_REASON}"
              echo "Container reason: ${CONTAINER_REASON}"
              echo ""
              echo "üìã Check migration logs at:"
              echo "https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fbcos-migrations-${{ steps.vars.outputs.TARGET_ENV }}"
              exit 1
            fi

            # Retry logic
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "‚è≥ Waiting 30 seconds before retry..."
              sleep 30
            fi

            ATTEMPT=$((ATTEMPT + 1))
          done

          # Final check
          if [ "$SUCCESS" = false ]; then
            echo ""
            echo "‚ùå All $MAX_ATTEMPTS migration attempts failed"
            echo "üìã Check migration logs at:"
            echo "https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fbcos-migrations-${{ steps.vars.outputs.TARGET_ENV }}"
            exit 1
          fi

      - name: Get current task definition
        run: |
          aws ecs describe-task-definition --task-definition ${{ steps.vars.outputs.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json

      - name: Update ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@4225e0b507142a2e432b018bc3ccb728559b437a # v1.2.0
        with:
          task-definition: task-definition.json
          container-name: bcos
          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.vars.outputs.IMAGE_TAG }}

      - name: Ensure CloudWatch log group exists
        run: |
          LOG_GROUP="/ecs/bcos-${{ steps.vars.outputs.TARGET_ENV }}"
          if ! aws logs describe-log-groups --log-group-name-prefix "${LOG_GROUP}" --query 'logGroups[?logGroupName==`'${LOG_GROUP}'`]' --output text | grep -q "${LOG_GROUP}"; then
            echo "Creating log group: ${LOG_GROUP}"
            aws logs create-log-group --log-group-name "${LOG_GROUP}"
            aws logs put-retention-policy --log-group-name "${LOG_GROUP}" --retention-in-days 30
          else
            echo "‚úÖ Log group already exists: ${LOG_GROUP}"
          fi

      - name: Check if ECS service exists
        id: check-service
        run: |
          if aws ecs describe-services --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} --services ${{ steps.vars.outputs.ECS_SERVICE }} --query 'services[?status!=`INACTIVE`]' --output text 2>/dev/null | grep -q .; then
            echo "service-exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Service exists and is active"
          else
            echo "service-exists=false" >> $GITHUB_OUTPUT  
            echo "‚ö†Ô∏è Service does not exist or is inactive"
          fi

      - name: Create ECS service (if it doesn't exist)  
        if: steps.check-service.outputs.service-exists == 'false'
        run: |
          # Get target group ARN from CDK stack outputs
          TARGET_GROUP_ARN=$(aws cloudformation describe-stacks --stack-name BCOS-StagingStack --query 'Stacks[0].Outputs[?OutputKey==`StagingTargetGroupArn`].OutputValue' --output text)
          echo "üéØ Target Group ARN: ${TARGET_GROUP_ARN}"
          
          # Get network configuration from CloudFormation exports
          PRIVATE_SUBNETS=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnetIds`].OutputValue' --output text)
          ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name BCOS-NetworkStack --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroupId`].OutputValue' --output text)
          echo "üîó Private Subnets: ${PRIVATE_SUBNETS}"
          echo "üõ°Ô∏è  ECS Security Group: ${ECS_SECURITY_GROUP}"
          
          # Create ECS service with proper load balancer configuration
          echo "üöÄ Creating ECS service: ${{ steps.vars.outputs.ECS_SERVICE }}"
          aws ecs create-service \
            --cluster ${{ steps.vars.outputs.ECS_CLUSTER }} \
            --service-name ${{ steps.vars.outputs.ECS_SERVICE }} \
            --task-definition ${{ steps.vars.outputs.ECS_TASK_DEFINITION }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${PRIVATE_SUBNETS}],securityGroups=[${ECS_SECURITY_GROUP}],assignPublicIp=DISABLED}" \
            --load-balancers "targetGroupArn=${TARGET_GROUP_ARN},containerName=bcos,containerPort=3000" \
            --health-check-grace-period-seconds 300 \
            --deployment-configuration "maximumPercent=200,minimumHealthyPercent=50" \
            --enable-execute-command
          
          echo "‚úÖ ECS service created successfully: ${{ steps.vars.outputs.ECS_SERVICE }}"

      - name: Deploy to ECS
        id: ecs-deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@df9643053eda01f169e64a0e60233aacca83799a # v1.5.0
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ steps.vars.outputs.ECS_SERVICE }}
          cluster: ${{ steps.vars.outputs.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Deployment summary
        run: |
          # Set application URL based on environment
          if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
            APP_URL="https://app.bendcare.com"
          else
            APP_URL="https://staging.bendcare.com"
          fi

          echo ""
          echo "‚úÖ ${{ steps.vars.outputs.TARGET_ENV }} deployment completed"
          echo "üåê Application URL: ${APP_URL}"
          echo ""
          echo "üìã Service logs:"
          echo "https://console.aws.amazon.com/ecs/home?region=us-east-1#/clusters/${{ steps.vars.outputs.ECS_CLUSTER }}/services/${{ steps.vars.outputs.ECS_SERVICE }}/logs"

      - name: Update deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ ${{ steps.vars.outputs.TARGET_ENV }} deployment completed successfully"
            if [ "${{ steps.vars.outputs.TARGET_ENV }}" = "production" ]; then
              echo "üåê Application URL: https://app.bendcare.com"
              echo "üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-production-Dashboard"
            else
              echo "üåê Application URL: https://staging.bendcare.com"
              echo "üìä Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=BCOS-staging-Dashboard"
            fi
          else
            echo "‚ùå ${{ steps.vars.outputs.TARGET_ENV }} deployment failed"
            echo "üîç Check logs: https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_REGION }}#/clusters/${{ steps.vars.outputs.ECS_CLUSTER }}/services/${{ steps.vars.outputs.ECS_SERVICE }}/logs"
          fi
